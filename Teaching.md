# Журнал обучения

Здесь мы будем записывать полные тексты каждого нашего "урока", чтобы вы всегда могли к ним вернуться.

---

### Урок 1: Общие концепции и архитектура (Поверхностный обзор)

*   **Клиент (Фронтенд):** Это то, что пользователь видит и с чем взаимодействует в браузере. В вашем случае — это папка `frontend`.
*   **Сервер (Бекенд):** Это "мозг" операции, работающий на Node.js. В вашем случае — это папка `backend`.
*   **Жизненный цикл HTTP-запроса:** Процесс, когда клиент (браузер) отправляет запрос (например, `GET /api/news`), сервер его обрабатывает (идет в базу данных) и отправляет ответ (данные в формате JSON).
*   **REST API:** Набор правил и соглашений, по которым клиент и сервер общаются друг с другом.
*   **Структура проекта:** Разобрали назначение папок `frontend`, `backend` и ключевых файлов `package.json` и `prisma/schema.prisma`.

---

### Урок 1.2: Глубокое погружение в жизненный цикл запроса

Давайте проследим полный путь одного запроса на примере загрузки новостей, глядя непосредственно в код.

#### Шаг 1: Запуск сервера (Бекенд) - `backend/src/index.ts`

Это сердце вашего бекенд-приложения.

1.  **Импорты:**
    *   `express` - сам фреймворк для создания сервера.
    *   `cors` - middleware, которое разрешает вашему фронтенду делать запросы к бекенду.
    *   `postRoutes`, `userRoutes` и т.д. - импорт файлов с маршрутами.

2.  **Создание приложения:**
    *   `const app = express();` - создаем "экземпляр" нашего сервера.

3.  **Настройка Middleware (`app.use(...)`):**
    *   Middleware — это код, который выполняется *перед* тем, как запрос дойдет до своей конечной точки.
    *   `app.use(cors(corsOptions));` - применяем `cors`.
    *   `app.use(express.json());` - критически важное middleware, превращает тело JSON-запроса в JavaScript-объект `req.body`.
    *   `app.use('/uploads', ...)` - раздает статические файлы (картинки) из папки `public`.

4.  **Подключение маршрутов:**
    *   `app.use('/api/posts', postRoutes);` - ключевая часть! Эта строка говорит: "Если придет запрос, URL которого начинается с `/api/posts`, то дальнейшую его обработку передай в `postRoutes`".

5.  **Запуск сервера:**
    *   `app.listen(PORT, ...)` - эта команда запускает сервер, и он начинает "слушать" входящие HTTP-запросы на указанном порту.

**Итог по файлу:** `index.ts` — это дирижер, который собирает все необходимые инструменты (middleware) и указывает, какой части оркестра (файлам маршрутов) играть.

#### Шаг 2: Диспетчерский пульт (Бекенд) - `backend/src/routes/postRoutes.ts`

Этот файл — диспетчерский пульт для всех URL, начинающихся с `/api/posts`.

1.  **Создание роутера:**
    *   `const router = express.Router();` - создаем специальный объект `router` для группировки маршрутов в отдельном файле.

2.  **Определение маршрутов:**
    *   `router.get("/news", newsController.getNews as RequestHandler);`
    *   `router.get`: Маршрут срабатывает только на `GET` запросы (для получения данных).
    *   `"/news"`: Путь. Полный URL будет `http://localhost:3000/api/posts/news`.
    *   `newsController.getNews`: Функция из контроллера, которая будет выполнена.

3.  **Безопасность:**
    *   Маршруты с `authMiddleware` и `requireAdmin` — это "охранники" (middleware). `authMiddleware` проверяет, залогинен ли пользователь, а `requireAdmin` — есть ли у него права администратора.

**Итог по файлу:** Файл маршрутов — это карта, которая сопоставляет конкретный URL и HTTP-метод с конкретной функцией-обработчиком (контроллером).

#### Шаг 3: Рабочий (Бекенд) - `backend/src/controllers/newsController.ts`

Здесь происходит вся "магия". Мы смотрим на функцию `getNews`.

1.  **Сигнатура функции:** `export const getNews: RequestHandler = async (req, res) => { ... }`
    *   `async (req, res)`: `async` говорит, что внутри будут асинхронные операции. `req` — объект с информацией о запросе, `res` — объект для отправки ответа.

2.  **Блок `try...catch`:**
    *   Весь код обернут в `try...catch`. Если внутри `try` произойдет ошибка, выполнение перейдет в `catch`, и клиенту вернется ошибка 500, но сервер не "упадет".

3.  **Взаимодействие с базой данных:**
    *   `const allNews = await prisma.news.findMany({ where });`
    *   Это — кульминация. `prisma` — это Prisma Client, который знает все о вашей базе данных.
    *   `prisma.news`: Обращение к модели `News`.
    *   `.findMany({ where })`: Метод для поиска множества записей. `await` ждет, пока база данных вернет результат.

4.  **Отправка ответа клиенту:**
    *   `res.status(200).json(paginatedNews);`
    *   `res.status(200)`: Устанавливает HTTP-статус "200 OK" (успех).
    *   `.json(paginatedNews)`: Превращает массив JavaScript-объектов в строку JSON и отправляет ее клиенту.

**Итог по файлу:** Контроллер — это рабочий, который получает задание от роутера, идет в базу данных с помощью `Prisma`, выполняет бизнес-логику (сортировка, фильтрация) и отправляет готовый результат клиенту.

#### Шаг 4: Инициатор (Фронтенд) - `frontend/src/pages/News.tsx`

Это React-компонент, который отвечает за отрисовку страницы новостей.

1.  **Определение состояния (State):**
    *   `const [news, setNews] = useState<NewsItem[]>([]);`
    *   Хук `useState` создает переменную состояния `news`. Когда вызывается функция `setNews`, React автоматически перерисовывает компонент для отображения новых данных.

2.  **Функция `fetchNews`:**
    *   `const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/posts/news`, { ... });`
    *   **Момент истины!** Клиент делает запрос. `axios.get` отправляет `GET` запрос на полный URL нашего API, включая параметры для пагинации и поиска.

3.  **Хук `useEffect`:**
    *   `useEffect` позволяет выполнять "побочные эффекты".
    *   `useEffect(() => { ... }, [searchQuery, ...]);` — код внутри выполнится при первом рендере, а затем каждый раз, когда изменится одна из зависимостей в массиве (например, `searchQuery`). Это и запускает `fetchNews`.

4.  **Рендеринг (JSX):**
    *   `{news.map((item) => ( ... ))}`
    *   Сердце отрисовки. Мы "пробегаемся" по нашему массиву состояния `news` и для каждого элемента `item` создаем HTML-блок. Когда `setNews` обновляет массив, React заново выполняет `.map()` и перерисовывает список на экране.

### Полная картина (итог урока 1.2)

1.  **Клиент (`News.tsx`):** `useEffect` вызывает `fetchNews`.
2.  **Клиент (`News.tsx`):** `axios.get` отправляет HTTP-запрос `GET http://.../api/posts/news`.
3.  **Сеть:** Запрос летит от браузера к серверу.
4.  **Бекенд (`index.ts`):** Принимает запрос и передает его в `postRoutes.ts`.
5.  **Бекенд (`postRoutes.ts`):** Видит `GET /news` и вызывает `newsController.getNews`.
6.  **Бекенд (`newsController.ts`):** Делает запрос к БД через `prisma.news.findMany()`.
7.  **Бекенд (`newsController.ts`):** Отправляет данные обратно в виде JSON.
8.  **Сеть:** JSON-ответ летит от сервера к браузеру.
9.  **Клиент (`News.tsx`):** `axios` получает ответ. `fetchNews` вызывает `setNews(response.data)`.
10. **Клиент (`News.tsx`):** React замечает изменение состояния и перерисовывает компонент, отображая новости.
