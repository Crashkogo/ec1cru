import React, { useCallback, useEffect, useState } from 'react';
import {
    Edit,
    SimpleForm,
    TextInput,
    BooleanInput,
    SelectInput,
    NumberInput,
    required,
    SaveButton,
    Toolbar,
    ListButton,
    TopToolbar,
} from 'react-admin';
import { Editor } from '@tinymce/tinymce-react';
import { useFormContext } from 'react-hook-form';
import { Card, Box, Typography, Checkbox, FormGroup, FormControlLabel } from '@mui/material';
import axios from 'axios';
import { transliterate } from '../../utils/transliterate';

const SERVER_BASE_URL = import.meta.env.VITE_API_URL;

interface Program {
    id: number;
    fullName: string;
    shortName: string;
}

const ContentInput = ({ source, label, ...props }: any) => {
    const { setValue, watch } = useFormContext();
    const content = watch(source);
    const [tempImages, setTempImages] = useState<string[]>([]);

    const extractTempImages = (htmlContent: string): string[] => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');
        const images = doc.querySelectorAll('img');
        const tempImageUrls: string[] = [];

        images.forEach((img) => {
            const src = img.getAttribute('src');
            if (src && src.includes('/uploads/ready-solutions/temp/') && !tempImageUrls.includes(src)) {
                tempImageUrls.push(src);
            }
        });

        return tempImageUrls;
    };

    const handleEditorChange = useCallback(
        (newContent: string) => {
            setValue(source, newContent, { shouldValidate: true });
            const tempUrls = extractTempImages(newContent);
            setTempImages(tempUrls);
        },
        [setValue, source]
    );

    return (
        <Box sx={{ mb: 2 }}>
            <Typography variant="body2" sx={{ mb: 1, fontWeight: 'medium' }}>
                {label}
            </Typography>
            <Editor
                tinymceScriptSrc="/tinymce/tinymce.min.js"
                value={content || ''}
                onEditorChange={handleEditorChange}
                init={{
                    height: 500,
                    menubar: true,
                    plugins: [
                        'advlist',
                        'autolink',
                        'lists',
                        'link',
                        'image',
                        'charmap',
                        'anchor',
                        'searchreplace',
                        'visualblocks',
                        'code',
                        'fullscreen',
                        'insertdatetime',
                        'media',
                        'table',
                        'help',
                        'wordcount',
                    ],
                    toolbar:
                        'undo redo | formatselect | bold italic underline strikethrough | ' +
                        'alignleft aligncenter alignright alignjustify | ' +
                        'bullist numlist outdent indent | link image | ' +
                        'removeformat | code | help',
                    base_url: '/tinymce',
                    suffix: '.min',
                    image_uploadtab: true,
                    images_upload_url: `${SERVER_BASE_URL}/api/posts/upload-image?entity=ready-solutions`,
                    images_upload_base_path: `${SERVER_BASE_URL}`,
                    automatic_uploads: true,
                    file_picker_types: 'image',
                    content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:14px }',
                }}
            />
        </Box>
    );
};

const SlugInput = ({ source, label, ...props }: any) => {
    const { setValue, watch } = useFormContext();
    const title = watch('title');
    const slug = watch(source);
    const [initialSlug] = useState(slug);
    const [isSlugManuallyEdited, setIsSlugManuallyEdited] = useState(false);

    useEffect(() => {
        // При первой загрузке проверяем, отличается ли текущий slug от автогенерированного
        if (initialSlug && title) {
            const autoGeneratedSlug = transliterate(title);
            if (initialSlug !== autoGeneratedSlug) {
                setIsSlugManuallyEdited(true);
            }
        }
    }, [initialSlug, title]);

    useEffect(() => {
        // Автогенерация slug только если он пустой или не был отредактирован вручную
        if (title && !isSlugManuallyEdited && (!slug || slug === '')) {
            const generatedSlug = transliterate(title);
            setValue(source, generatedSlug);
        }
    }, [title, slug, setValue, source, isSlugManuallyEdited]);

    const handleSlugChange = (value: string) => {
        setIsSlugManuallyEdited(true);
        setValue(source, value);
    };

    return (
        <TextInput
            source={source}
            label={label}
            helperText="Изменение slug может нарушить существующие ссылки"
            onChange={handleSlugChange}
            {...props}
        />
    );
};

const ImageGalleryInput = ({ source, label, ...props }: any) => {
    const { setValue, watch } = useFormContext();
    const currentImages = watch(source);
    const [galleryImages, setGalleryImages] = useState<string[]>([]);

    useEffect(() => {
        if (currentImages && Array.isArray(currentImages)) {
            // Нормализуем URL изображений - убираем домен если он есть
            const normalizedImages = currentImages.map((img: string) => {
                if (img.startsWith('http')) {
                    // Извлекаем только путь из полного URL
                    const url = new URL(img);
                    return url.pathname;
                }
                return img;
            });
            setGalleryImages(normalizedImages);
        }
    }, [currentImages]);

    const handleGalleryImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const files = e.target.files;
        if (!files) return;

        const token = localStorage.getItem('token');
        const uploadedImages: string[] = [];

        for (const file of Array.from(files)) {
            const formData = new FormData();
            formData.append('image', file);

            try {
                const response = await axios.post(
                    `${SERVER_BASE_URL}/api/posts/upload-gallery-image`,
                    formData,
                    {
                        headers: {
                            Authorization: `Bearer ${token}`,
                            'Content-Type': 'multipart/form-data',
                        },
                    }
                );
                // Сохраняем только относительный путь
                uploadedImages.push(response.data.url);
            } catch (error) {
                console.error('Error uploading gallery image:', error);
            }
        }

        const newImages = [...galleryImages, ...uploadedImages];
        setGalleryImages(newImages);
        setValue(source, newImages);
    };

    const removeImage = (indexToRemove: number) => {
        const newImages = galleryImages.filter((_, index) => index !== indexToRemove);
        setGalleryImages(newImages);
        setValue(source, newImages);
    };

    return (
        <Box sx={{ mb: 2 }}>
            <Typography variant="body2" sx={{ mb: 1, fontWeight: 'medium' }}>
                {label}
            </Typography>
            <input
                type="file"
                multiple
                accept="image/*"
                onChange={handleGalleryImageUpload}
                style={{
                    width: '100%',
                    padding: '8px',
                    border: '1px solid #ccc',
                    borderRadius: '4px',
                    marginBottom: '8px'
                }}
            />
            {galleryImages.length > 0 && (
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                    {galleryImages.map((img, idx) => (
                        <Box key={idx} sx={{ position: 'relative' }}>
                            <img
                                src={img.startsWith('http') ? img : `${SERVER_BASE_URL}${img}`}
                                alt="Preview"
                                style={{
                                    width: '80px',
                                    height: '80px',
                                    objectFit: 'cover',
                                    borderRadius: '4px'
                                }}
                                onError={(e) => {
                                    console.error('Error loading image:', img);
                                    // Пробуем загрузить без домена
                                    const target = e.target as HTMLImageElement;
                                    if (target.src.includes('http')) {
                                        const url = new URL(target.src);
                                        target.src = `${SERVER_BASE_URL}${url.pathname}`;
                                    }
                                }}
                            />
                            <button
                                type="button"
                                onClick={() => removeImage(idx)}
                                style={{
                                    position: 'absolute',
                                    top: '-5px',
                                    right: '-5px',
                                    backgroundColor: 'red',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '50%',
                                    width: '20px',
                                    height: '20px',
                                    fontSize: '12px',
                                    cursor: 'pointer',
                                }}
                            >
                                ×
                            </button>
                        </Box>
                    ))}
                </Box>
            )}
        </Box>
    );
};

const ProgramCheckboxes = ({ source, label, ...props }: any) => {
    const { setValue, watch } = useFormContext();
    const currentPrograms = watch('programs');
    const [programs, setPrograms] = useState<Program[]>([]);
    const [selectedPrograms, setSelectedPrograms] = useState<number[]>([]);

    useEffect(() => {
        const token = localStorage.getItem('token');
        axios
            .get(`${SERVER_BASE_URL}/api/posts/admin/programs`, {
                headers: { Authorization: `Bearer ${token}` },
            })
            .then((response) => setPrograms(response.data))
            .catch((error) => console.error('Error fetching programs:', error));
    }, []);

    useEffect(() => {
        if (currentPrograms && Array.isArray(currentPrograms)) {
            const programIds = currentPrograms.map((p: any) => p.program.id);
            setSelectedPrograms(programIds);
        }
    }, [currentPrograms]);

    const handleProgramChange = (programId: number, checked: boolean) => {
        const newSelected = checked
            ? [...selectedPrograms, programId]
            : selectedPrograms.filter(id => id !== programId);

        setSelectedPrograms(newSelected);
        setValue(source, newSelected);
    };

    return (
        <Box sx={{ mb: 2 }}>
            <Typography variant="body2" sx={{ mb: 1, fontWeight: 'medium' }}>
                {label}
            </Typography>
            <Box sx={{ border: '1px solid #ccc', borderRadius: 1, p: 1, maxHeight: 200, overflow: 'auto' }}>
                <FormGroup>
                    {programs.map((program) => (
                        <FormControlLabel
                            key={program.id}
                            control={
                                <Checkbox
                                    checked={selectedPrograms.includes(program.id)}
                                    onChange={(e) => handleProgramChange(program.id, e.target.checked)}
                                />
                            }
                            label={`${program.fullName} (${program.shortName})`}
                        />
                    ))}
                </FormGroup>
            </Box>
        </Box>
    );
};

const ReadySolutionsEditActions = () => (
    <TopToolbar>
        <ListButton />
    </TopToolbar>
);

const ReadySolutionsEditToolbar = () => (
    <Toolbar>
        <SaveButton />
    </Toolbar>
);

export const ReadySolutionsEdit = () => (
    <Edit title="Редактирование готового решения" actions={<ReadySolutionsEditActions />}>
        <Card className="p-6">
            <SimpleForm toolbar={<ReadySolutionsEditToolbar />}>
                <SelectInput
                    source="type"
                    label="Тип решения"
                    choices={[
                        { id: 'PROCESSING', name: 'Обработка' },
                        { id: 'PRINT_FORM', name: 'Печатная форма' },
                        { id: 'REPORT', name: 'Отчёт' },
                    ]}
                    validate={required()}
                    fullWidth
                />

                <BooleanInput source="freshSupport" label="Поддержка 1C:Fresh" />

                <TextInput
                    source="title"
                    label="Название"
                    validate={required()}
                    fullWidth
                />

                <SlugInput
                    source="slug"
                    label="Slug"
                    validate={required()}
                    fullWidth
                />

                <TextInput
                    source="shortDescription"
                    label="Краткое описание"
                    validate={required()}
                    fullWidth
                    multiline
                    rows={3}
                />

                <ContentInput
                    source="fullDescription"
                    label="Полное описание"
                    validate={required()}
                />

                <NumberInput
                    source="price"
                    label="Цена"
                    validate={required()}
                    min={0}
                    step={0.01}
                />

                <ProgramCheckboxes
                    source="programIds"
                    label="Программы"
                />

                <ImageGalleryInput
                    source="images"
                    label="Изображения для галереи"
                />

                <BooleanInput source="isPublished" label="Опубликовать" />

                <TextInput source="metaTitle" label="Meta Title" fullWidth />

                <TextInput
                    source="metaDescription"
                    label="Meta Description"
                    fullWidth
                    multiline
                    rows={3}
                />
            </SimpleForm>
        </Card>
    </Edit>
);

export default ReadySolutionsEdit; 